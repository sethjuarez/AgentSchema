{#
  Python File Template
  ====================
  Renders a complete Python file containing one or more dataclasses.
  
  Expected context (PythonFileContext):
    - containsAbstract: boolean
    - typings: string[]
    - imports: string[]
    - classes: PythonClassContext[]
    - typeMapper: Record<string, string>
#}
{%- import "_macros.njk" as py -%}
##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
{% if containsAbstract %}
from abc import ABC
{%- endif %}
from dataclasses import dataclass, field
from typing import Any, ClassVar, Optional

from ._context import LoadContext, SaveContext
{%- for import in imports %}
from ._{{ import }} import {{ import }}
{%- endfor %}

{% for classCtx in classes %}
{%- set node = classCtx.node -%}
{%- set typeMapper = classCtx.typeMapper -%}
{%- set alternates = classCtx.alternates -%}
{%- set polymorphicTypes = classCtx.polymorphicTypes -%}
{%- set collectionTypes = classCtx.collectionTypes %}

@dataclass
class {{ node.typeName.name }}{% if node.base %}({{ node.base.name }}){% endif %}{% if node.isAbstract %}(ABC){% endif %}:
    """{% for line in node.description.split('\n') %}{{ line }}
    {% endfor %}
    Attributes
    ----------
{%- for prop in node.properties %}
    {{ prop.name }} : {{ py.pythonType(prop, typeMapper) }}
        {{ prop.description }}
{%- endfor %}
    """

    _shorthand_property: ClassVar[Optional[str]] = {% if classCtx.shorthandProperty %}"{{ classCtx.shorthandProperty }}"{% else %}None{% endif %}
{% for prop in node.properties %}
    {{ prop.name }}: {{ py.pythonType(prop, typeMapper) }}{{ py.defaultValue(prop, typeMapper) }}
{%- endfor %}

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "{{ node.typeName.name }}":
        """Load a {{ node.typeName.name }} instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            {{ node.typeName.name }}: The loaded {{ node.typeName.name }} instance.

        """
        
        if context is not None:
            data = context.process_input(data)
        {% if alternates.length > 0 %}
        # handle alternate representations
{%- for alt in alternates %}
        if isinstance(data, {{ alt.scalar }}):
            data = {{ alt.alternate }}
{%- endfor %}
        {% endif %}
        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for {{ node.typeName.name }}: {data}")
{% if polymorphicTypes %}
        # load polymorphic {{ node.typeName.name }} instance
        instance = {{ node.typeName.name }}.load_{{ node.discriminator }}(data, context)
{% else %}
        # create new instance
        instance = {{ node.typeName.name }}()
{%- endif %}
{% for prop in node.properties %}
        if data is not None and "{{ prop.name }}" in data:
            {{ py.setInstance(prop, "instance", "data", node.typeName.name) }}
{%- endfor %}
        if context is not None:
            instance = context.process_output(instance)
        return instance
{% for collection in collectionTypes %}

    @staticmethod
    def load_{{ collection.prop.name }}(data: dict | list, context: Optional[LoadContext]) -> list[{{ collection.prop.typeName.name }}]:
        if isinstance(data, dict):
            # convert simple named {{ collection.prop.name }} to list of {{ collection.prop.typeName.name }}
            result = []
            for k, v in data.items():
                if isinstance(v, dict):
                    # value is an object, spread its properties
                    result.append({"name": k, **v})
                else:
                    # value is a scalar, use it as the primary property
                    result.append({"name": k, "{{collection.type[0]}}": v})
            data = result
        return [{{ collection.prop.typeName.name }}.load(item, context) for item in data]

    @staticmethod
    def save_{{ collection.prop.name }}(items: list[{{ collection.prop.typeName.name }}], context: Optional[SaveContext]) -> dict[str, Any] | list[dict[str, Any]]:
        if context is None:
            context = SaveContext()
        
        if context.collection_format == "array":
            return [item.save(context) for item in items]
        
        # Object format: use name as key
        result: dict[str, Any] = {}
        for item in items:
            item_data = item.save(context)
            name = item_data.pop("name", None)
            if name:
                # Check if we can use shorthand (only primary property set)
                if context.use_shorthand and hasattr(item, '_shorthand_property'):
                    shorthand_prop = item._shorthand_property
                    if shorthand_prop and len(item_data) == 1 and shorthand_prop in item_data:
                        result[name] = item_data[shorthand_prop]
                        continue
                result[name] = item_data
            else:
                # No name, fall back to array format for this item
                if "_unnamed" not in result:
                    result["_unnamed"] = []
                result["_unnamed"].append(item_data)
        return result
{%- endfor %}
{% if polymorphicTypes %}

    @staticmethod
    def load_{{ node.discriminator }}(data: dict, context: Optional[LoadContext]) -> "{{ node.typeName.name }}":
        # load polymorphic {{ node.typeName.name }} instance
        if data is not None and "{{ node.discriminator }}" in data:
            discriminator_value = str(data["{{ node.discriminator }}"]).lower()
{%- for type in polymorphicTypes.types %}
            {% if loop.first %}if{% else %}elif{% endif %} discriminator_value == "{{ type.value }}":
                return {{ type.instance.typeName.name }}.load(data, context)
{%- endfor %}
{% if polymorphicTypes.default %}
            else:
{% if polymorphicTypes.default.instance.typeName.name == node.typeName.name %}
                # create new instance (stop recursion)
                return {{ node.typeName.name }}()
{% else %}
                # load default instance
                return {{ polymorphicTypes.default.instance.typeName.name }}.load(data, context)
{%- endif %}
{% else %}
            else:
                raise ValueError(f"Unknown {{ node.typeName.name }} discriminator value: {discriminator_value}")
{%- endif %}
        else:
{% if node.isAbstract %}
            raise ValueError("Missing {{ node.typeName.name }} discriminator property: '{{ node.discriminator }}'")
{% else %}
            # create new instance
            return {{ node.typeName.name }}()
{%- endif %}
{%- endif %}

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the {{ node.typeName.name }} instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)
        
{% if node.base %}
        # Start with parent class properties
        result = super().save(context)
{% else %}
        result: dict[str, Any] = {}
{%- endif %}
{% for prop in node.properties %}
        if obj.{{ prop.name }} is not None:
            {{ py.saveProperty(prop, "obj", "result", node.typeName.name) }}
{%- endfor %}
{% if not node.base %}
        if context is not None:
            result = context.process_dict(result)
{%- endif %}
        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the {{ node.typeName.name }} instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the {{ node.typeName.name }} instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)
{% endfor %}
