##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from abc import ABC
from dataclasses import dataclass, field
from typing import Any, Optional
from ._EnvironmentVariable import EnvironmentVariable
from ._Model import Model
from ._PropertySchema import PropertySchema
from ._ProtocolVersionRecord import ProtocolVersionRecord
from ._Template import Template
from ._Tool import Tool


@dataclass
class AgentDefinition(ABC):
    """The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.It provides a way to create reusable and composable AI agents that can be executed with specific configurations.The specification includes metadata about the agent, model configuration, input parameters, expected outputs,available tools, and template configurations for prompt rendering.
    Attributes
    ----------
    kind : str
        Kind represented by the document
    name : str
        Human-readable name of the agent
    displayName : Optional[str]
        Display name of the agent for UI purposes
    description : Optional[str]
        Description of the agent's capabilities and purpose
    metadata : Optional[dict[str, Any]]
        Additional metadata including authors, tags, and other arbitrary properties
    inputSchema : Optional[PropertySchema]
        Input parameters that participate in template rendering
    outputSchema : Optional[PropertySchema]
        Expected output format and structure from the agent
    """

    kind: str = field(default="")
    name: str = field(default="")
    displayName: Optional[str] = field(default="")
    description: Optional[str] = field(default="")
    metadata: Optional[dict[str, Any]] = field(default_factory=dict)
    inputSchema: Optional[PropertySchema] = field(default=None)
    outputSchema: Optional[PropertySchema] = field(default=None)

    @staticmethod
    def load(data: Any) -> "AgentDefinition":
        """Load a AgentDefinition instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for AgentDefinition: {data}")

        # load polymorphic AgentDefinition instance
        instance = AgentDefinition.load_kind(data)
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "displayName" in data:
            instance.displayName = data["displayName"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "metadata" in data:
            instance.metadata = data["metadata"]
        if data is not None and "inputSchema" in data:
            instance.inputSchema = PropertySchema.load(data["inputSchema"])
        if data is not None and "outputSchema" in data:
            instance.outputSchema = PropertySchema.load(data["outputSchema"])
        return instance

    @staticmethod
    def load_kind(data: dict) -> "AgentDefinition":
        # load polymorphic AgentDefinition instance
        if data is not None and "kind" in data:
            discriminator_value = data["kind"]
            if discriminator_value == "prompt":
                return PromptAgent.load(data)
            elif discriminator_value == "workflow":
                return Workflow.load(data)
            elif discriminator_value == "hosted":
                return ContainerAgent.load(data)
            else:
                raise ValueError(
                    f"Unknown AgentDefinition discriminator value: {discriminator_value}"
                )
        else:
            raise ValueError("Missing AgentDefinition discriminator property: 'kind'")


@dataclass
class PromptAgent(AgentDefinition):
    """Prompt based agent definition. Used to create agents that can be executed directly.These agents can leverage tools, input parameters, and templates to generate responses.They are designed to be straightforward and easy to use for various applications.
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'prompt'
    model : Model
        Primary AI model configuration for the agent
    tools : Optional[list[Tool]]
        Tools available to the agent for extended functionality
    template : Optional[Template]
        Template configuration for prompt rendering
    instructions : Optional[str]
        Give your agent clear directions on what to do and how to do it. Include specific tasks, their order, and any special instructions like tone or engagement style. (can use this for a pure yaml declaration or as content in the markdown format)
    additionalInstructions : Optional[str]
        Additional instructions or context for the agent, can be used to provide extra guidance (can use this for a pure yaml declaration)
    """

    kind: str = field(default="prompt")
    model: Model = field(default_factory=Model)
    tools: Optional[list[Tool]] = field(default_factory=list)
    template: Optional[Template] = field(default=None)
    instructions: Optional[str] = field(default="")
    additionalInstructions: Optional[str] = field(default="")

    @staticmethod
    def load(data: Any) -> "PromptAgent":
        """Load a PromptAgent instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for PromptAgent: {data}")

        # create new instance
        instance = PromptAgent()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "model" in data:
            instance.model = Model.load(data["model"])
        if data is not None and "tools" in data:
            instance.tools = PromptAgent.load_tools(data["tools"])
        if data is not None and "template" in data:
            instance.template = Template.load(data["template"])
        if data is not None and "instructions" in data:
            instance.instructions = data["instructions"]
        if data is not None and "additionalInstructions" in data:
            instance.additionalInstructions = data["additionalInstructions"]
        return instance

    @staticmethod
    def load_tools(data: dict | list) -> list[Tool]:
        if isinstance(data, dict):
            # convert simple named tools to list of Tool
            if len(data.keys()) == 1:
                data = [{"name": k, "kind": v} for k, v in data.items()]
            else:
                data = [{"name": k, **v} for k, v in data.items()]
        return [Tool.load(item) for item in data]


@dataclass
class Workflow(AgentDefinition):
    """A workflow agent that can orchestrate multiple steps and actions.This agent type is designed to handle complex workflows that may involvemultiple tools, models, and decision points.The workflow agent can be configured with a series of steps that definethe flow of execution, including conditional logic and parallel processing.This allows for the creation of sophisticated AI-driven processes that canadapt to various scenarios and requirements.Note: The detailed structure of the workflow steps and actions is not defined hereand would need to be implemented based on specific use cases and requirements.
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'workflow'
    trigger : Optional[dict[str, Any]]
        The steps that make up the workflow
    """

    kind: str = field(default="workflow")
    trigger: Optional[dict[str, Any]] = field(default_factory=dict)

    @staticmethod
    def load(data: Any) -> "Workflow":
        """Load a Workflow instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Workflow: {data}")

        # create new instance
        instance = Workflow()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "trigger" in data:
            instance.trigger = data["trigger"]
        return instance


@dataclass
class ContainerAgent(AgentDefinition):
    """This represents a container based agent hosted by the provider/publisher.The intent is to represent a container application that the user wants to runin a hosted environment that the provider manages.
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'hosted'
    protocols : list[ProtocolVersionRecord]
        Protocol used by the containerized agent
    environmentVariables : Optional[list[EnvironmentVariable]]
        Environment variables to set in the container
    """

    kind: str = field(default="hosted")
    protocols: list[ProtocolVersionRecord] = field(default_factory=list)
    environmentVariables: Optional[list[EnvironmentVariable]] = field(
        default_factory=list
    )

    @staticmethod
    def load(data: Any) -> "ContainerAgent":
        """Load a ContainerAgent instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for ContainerAgent: {data}")

        # create new instance
        instance = ContainerAgent()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "protocols" in data:
            instance.protocols = ContainerAgent.load_protocols(data["protocols"])
        if data is not None and "environmentVariables" in data:
            instance.environmentVariables = ContainerAgent.load_environmentVariables(
                data["environmentVariables"]
            )
        return instance

    @staticmethod
    def load_protocols(data: dict | list) -> list[ProtocolVersionRecord]:
        if isinstance(data, dict):
            # convert simple named protocols to list of ProtocolVersionRecord
            if len(data.keys()) == 1:
                data = [{"name": k, "protocol": v} for k, v in data.items()]
            else:
                data = [{"name": k, **v} for k, v in data.items()]
        return [ProtocolVersionRecord.load(item) for item in data]

    @staticmethod
    def load_environmentVariables(data: dict | list) -> list[EnvironmentVariable]:
        if isinstance(data, dict):
            # convert simple named environmentVariables to list of EnvironmentVariable
            if len(data.keys()) == 1:
                data = [{"name": k, "value": v} for k, v in data.items()]
            else:
                data = [{"name": k, **v} for k, v in data.items()]
        return [EnvironmentVariable.load(item) for item in data]
