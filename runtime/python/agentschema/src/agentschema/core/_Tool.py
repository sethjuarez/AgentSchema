##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################

from abc import ABC
from dataclasses import dataclass, field
from typing import Any, ClassVar, Optional

from ._context import LoadContext, SaveContext
from ._Binding import Binding
from ._Connection import Connection
from ._McpServerApprovalMode import McpServerApprovalMode
from ._PropertySchema import PropertySchema


@dataclass
class Tool(ABC):
    """Represents a tool that can be used in prompts.

    Attributes
    ----------
    name : str
        Name of the tool. If a function tool, this is the function name, otherwise it is the type
    kind : str
        The kind identifier for the tool
    description : Optional[str]
        A short description of the tool for metadata purposes
    bindings : list[Binding]
        Tool argument bindings to input properties
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    name: str = field(default="")
    kind: str = field(default="")
    description: Optional[str] = None
    bindings: list[Binding] = field(default_factory=list)

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "Tool":
        """Load a Tool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            Tool: The loaded Tool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Tool: {data}")

        # load polymorphic Tool instance
        instance = Tool.load_kind(data, context)

        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "bindings" in data:
            instance.bindings = Tool.load_bindings(data["bindings"], context)
        if context is not None:
            instance = context.process_output(instance)
        return instance

    @staticmethod
    def load_bindings(
        data: dict | list, context: Optional[LoadContext]
    ) -> list[Binding]:
        if isinstance(data, dict):
            # convert simple named bindings to list of Binding
            result = []
            for k, v in data.items():
                if isinstance(v, dict):
                    # value is an object, spread its properties
                    result.append({"name": k, **v})
                else:
                    # value is a scalar, use it as the primary property
                    result.append({"name": k, "input": v})
            data = result
        return [Binding.load(item, context) for item in data]

    @staticmethod
    def save_bindings(
        items: list[Binding], context: Optional[SaveContext]
    ) -> dict[str, Any] | list[dict[str, Any]]:
        if context is None:
            context = SaveContext()

        if context.collection_format == "array":
            return [item.save(context) for item in items]

        # Object format: use name as key
        result: dict[str, Any] = {}
        for item in items:
            item_data = item.save(context)
            name = item_data.pop("name", None)
            if name:
                # Check if we can use shorthand (only primary property set)
                if context.use_shorthand and hasattr(item, "_shorthand_property"):
                    shorthand_prop = item._shorthand_property
                    if (
                        shorthand_prop
                        and len(item_data) == 1
                        and shorthand_prop in item_data
                    ):
                        result[name] = item_data[shorthand_prop]
                        continue
                result[name] = item_data
            else:
                # No name, fall back to array format for this item
                if "_unnamed" not in result:
                    result["_unnamed"] = []
                result["_unnamed"].append(item_data)
        return result

    @staticmethod
    def load_kind(data: dict, context: Optional[LoadContext]) -> "Tool":
        # load polymorphic Tool instance
        if data is not None and "kind" in data:
            discriminator_value = str(data["kind"]).lower()
            if discriminator_value == "function":
                return FunctionTool.load(data, context)
            elif discriminator_value == "bing_search":
                return WebSearchTool.load(data, context)
            elif discriminator_value == "file_search":
                return FileSearchTool.load(data, context)
            elif discriminator_value == "mcp":
                return McpTool.load(data, context)
            elif discriminator_value == "openapi":
                return OpenApiTool.load(data, context)
            elif discriminator_value == "code_interpreter":
                return CodeInterpreterTool.load(data, context)

            else:

                # load default instance
                return CustomTool.load(data, context)

        else:

            raise ValueError("Missing Tool discriminator property: 'kind'")

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the Tool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        result: dict[str, Any] = {}

        if obj.name is not None:
            result["name"] = obj.name
        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.description is not None:
            result["description"] = obj.description
        if obj.bindings is not None:
            result["bindings"] = Tool.save_bindings(obj.bindings, context)

        if context is not None:
            result = context.process_dict(result)
        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the Tool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the Tool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class FunctionTool(Tool):
    """Represents a local function tool.

    Attributes
    ----------
    kind : str
        The kind identifier for function tools
    parameters : PropertySchema
        Parameters accepted by the function tool
    strict : Optional[bool]
        Indicates whether the function tool enforces strict validation on its parameters
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="function")
    parameters: PropertySchema = field(default_factory=PropertySchema)
    strict: Optional[bool] = None

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "FunctionTool":
        """Load a FunctionTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            FunctionTool: The loaded FunctionTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for FunctionTool: {data}")

        # create new instance
        instance = FunctionTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "parameters" in data:
            instance.parameters = PropertySchema.load(data["parameters"], context)
        if data is not None and "strict" in data:
            instance.strict = data["strict"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the FunctionTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.parameters is not None:
            result["parameters"] = obj.parameters.save(context)
        if obj.strict is not None:
            result["strict"] = obj.strict

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the FunctionTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the FunctionTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class CustomTool(Tool):
    """Represents a generic server tool that runs on a server
    This tool kind is designed for operations that require server-side execution
    It may include features such as authentication, data storage, and long-running processes
    This tool kind is ideal for tasks that involve complex computations or access to secure resources
    Server tools can be used to offload heavy processing from client applications

    Attributes
    ----------
    kind : str
        The kind identifier for server tools. This is a wildcard and can represent any server tool type not explicitly defined.
    connection : Connection
        Connection configuration for the server tool
    options : dict[str, Any]
        Configuration options for the server tool
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="*")
    connection: Connection = field(default_factory=Connection)
    options: dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "CustomTool":
        """Load a CustomTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            CustomTool: The loaded CustomTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for CustomTool: {data}")

        # create new instance
        instance = CustomTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"], context)
        if data is not None and "options" in data:
            instance.options = data["options"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the CustomTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.connection is not None:
            result["connection"] = obj.connection.save(context)
        if obj.options is not None:
            result["options"] = obj.options

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the CustomTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the CustomTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class WebSearchTool(Tool):
    """The Bing search tool.

    Attributes
    ----------
    kind : str
        The kind identifier for Bing search tools
    connection : Connection
        The connection configuration for the Bing search tool
    options : Optional[dict[str, Any]]
        The configuration options for the Bing search tool
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="bing_search")
    connection: Connection = field(default_factory=Connection)
    options: Optional[dict[str, Any]] = None

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "WebSearchTool":
        """Load a WebSearchTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            WebSearchTool: The loaded WebSearchTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for WebSearchTool: {data}")

        # create new instance
        instance = WebSearchTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"], context)
        if data is not None and "options" in data:
            instance.options = data["options"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the WebSearchTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.connection is not None:
            result["connection"] = obj.connection.save(context)
        if obj.options is not None:
            result["options"] = obj.options

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the WebSearchTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the WebSearchTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class FileSearchTool(Tool):
    """A tool for searching files.
    This tool allows an AI agent to search for files based on a query.

    Attributes
    ----------
    kind : str
        The kind identifier for file search tools
    connection : Connection
        The connection configuration for the file search tool
    vectorStoreIds : list[str]
        The IDs of the vector stores to search within.
    maximumResultCount : Optional[int]
        The maximum number of search results to return.
    ranker : Optional[str]
        File search ranker.
    scoreThreshold : Optional[float]
        Ranker search threshold.
    filters : Optional[dict[str, Any]]
        Additional filters to apply during the file search.
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="file_search")
    connection: Connection = field(default_factory=Connection)
    vectorStoreIds: list[str] = field(default_factory=list)
    maximumResultCount: Optional[int] = None
    ranker: Optional[str] = None
    scoreThreshold: Optional[float] = None
    filters: Optional[dict[str, Any]] = None

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "FileSearchTool":
        """Load a FileSearchTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            FileSearchTool: The loaded FileSearchTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for FileSearchTool: {data}")

        # create new instance
        instance = FileSearchTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"], context)
        if data is not None and "vectorStoreIds" in data:
            instance.vectorStoreIds = data["vectorStoreIds"]
        if data is not None and "maximumResultCount" in data:
            instance.maximumResultCount = data["maximumResultCount"]
        if data is not None and "ranker" in data:
            instance.ranker = data["ranker"]
        if data is not None and "scoreThreshold" in data:
            instance.scoreThreshold = data["scoreThreshold"]
        if data is not None and "filters" in data:
            instance.filters = data["filters"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the FileSearchTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.connection is not None:
            result["connection"] = obj.connection.save(context)
        if obj.vectorStoreIds is not None:
            result["vectorStoreIds"] = obj.vectorStoreIds
        if obj.maximumResultCount is not None:
            result["maximumResultCount"] = obj.maximumResultCount
        if obj.ranker is not None:
            result["ranker"] = obj.ranker
        if obj.scoreThreshold is not None:
            result["scoreThreshold"] = obj.scoreThreshold
        if obj.filters is not None:
            result["filters"] = obj.filters

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the FileSearchTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the FileSearchTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class McpTool(Tool):
    """The MCP Server tool.

    Attributes
    ----------
    kind : str
        The kind identifier for MCP tools
    connection : Connection
        The connection configuration for the MCP tool
    serverName : str
        The server name of the MCP tool
    serverDescription : Optional[str]
        The description of the MCP tool
    approvalMode : McpServerApprovalMode
        The approval mode for the MCP tool, either 'auto' or 'manual'
    allowedTools : list[str]
        List of allowed operations or resources for the MCP tool
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="mcp")
    connection: Connection = field(default_factory=Connection)
    serverName: str = field(default="")
    serverDescription: Optional[str] = None
    approvalMode: McpServerApprovalMode = field(default_factory=McpServerApprovalMode)
    allowedTools: list[str] = field(default_factory=list)

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "McpTool":
        """Load a McpTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            McpTool: The loaded McpTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for McpTool: {data}")

        # create new instance
        instance = McpTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"], context)
        if data is not None and "serverName" in data:
            instance.serverName = data["serverName"]
        if data is not None and "serverDescription" in data:
            instance.serverDescription = data["serverDescription"]
        if data is not None and "approvalMode" in data:
            instance.approvalMode = McpServerApprovalMode.load(
                data["approvalMode"], context
            )
        if data is not None and "allowedTools" in data:
            instance.allowedTools = data["allowedTools"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the McpTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.connection is not None:
            result["connection"] = obj.connection.save(context)
        if obj.serverName is not None:
            result["serverName"] = obj.serverName
        if obj.serverDescription is not None:
            result["serverDescription"] = obj.serverDescription
        if obj.approvalMode is not None:
            result["approvalMode"] = obj.approvalMode.save(context)
        if obj.allowedTools is not None:
            result["allowedTools"] = obj.allowedTools

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the McpTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the McpTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class OpenApiTool(Tool):
    """

    Attributes
    ----------
    kind : str
        The kind identifier for OpenAPI tools
    connection : Connection
        The connection configuration for the OpenAPI tool
    specification : str
        The full OpenAPI specification
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="openapi")
    connection: Connection = field(default_factory=Connection)
    specification: str = field(default="")

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "OpenApiTool":
        """Load a OpenApiTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            OpenApiTool: The loaded OpenApiTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for OpenApiTool: {data}")

        # create new instance
        instance = OpenApiTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"], context)
        if data is not None and "specification" in data:
            instance.specification = data["specification"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the OpenApiTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.connection is not None:
            result["connection"] = obj.connection.save(context)
        if obj.specification is not None:
            result["specification"] = obj.specification

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the OpenApiTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the OpenApiTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)


@dataclass
class CodeInterpreterTool(Tool):
    """A tool for interpreting and executing code.
    This tool allows an AI agent to run code snippets and analyze data files.

    Attributes
    ----------
    kind : str
        The kind identifier for code interpreter tools
    fileIds : list[str]
        The IDs of the files to be used by the code interpreter tool.
    """

    _shorthand_property: ClassVar[Optional[str]] = None

    kind: str = field(default="code_interpreter")
    fileIds: list[str] = field(default_factory=list)

    @staticmethod
    def load(data: Any, context: Optional[LoadContext] = None) -> "CodeInterpreterTool":
        """Load a CodeInterpreterTool instance.
        Args:
            data (Any): The data to load the instance from.
            context (Optional[LoadContext]): Optional context with pre/post processing callbacks.
        Returns:
            CodeInterpreterTool: The loaded CodeInterpreterTool instance.

        """

        if context is not None:
            data = context.process_input(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for CodeInterpreterTool: {data}")

        # create new instance
        instance = CodeInterpreterTool()

        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "fileIds" in data:
            instance.fileIds = data["fileIds"]
        if context is not None:
            instance = context.process_output(instance)
        return instance

    def save(self, context: Optional[SaveContext] = None) -> dict[str, Any]:
        """Save the CodeInterpreterTool instance to a dictionary.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            dict[str, Any]: The dictionary representation of this instance.

        """
        obj = self
        if context is not None:
            obj = context.process_object(obj)

        # Start with parent class properties
        result = super().save(context)

        if obj.kind is not None:
            result["kind"] = obj.kind
        if obj.fileIds is not None:
            result["fileIds"] = obj.fileIds

        return result

    def to_yaml(self, context: Optional[SaveContext] = None) -> str:
        """Convert the CodeInterpreterTool instance to a YAML string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
        Returns:
            str: The YAML string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_yaml(self.save(context))

    def to_json(self, context: Optional[SaveContext] = None, indent: int = 2) -> str:
        """Convert the CodeInterpreterTool instance to a JSON string.
        Args:
            context (Optional[SaveContext]): Optional context with pre/post processing callbacks.
            indent (int): Number of spaces for indentation. Defaults to 2.
        Returns:
            str: The JSON string representation of this instance.

        """
        if context is None:
            context = SaveContext()
        return context.to_json(self.save(context), indent)
