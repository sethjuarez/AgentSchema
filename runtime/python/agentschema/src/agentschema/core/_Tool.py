##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from abc import ABC
from dataclasses import dataclass, field
from typing import Any, Optional
from ._Binding import Binding
from ._Connection import Connection
from ._McpServerApprovalMode import McpServerApprovalMode
from ._PropertySchema import PropertySchema


@dataclass
class Tool(ABC):
    """Represents a tool that can be used in prompts.
    Attributes
    ----------
    name : str
        Name of the tool. If a function tool, this is the function name, otherwise it is the type
    kind : str
        The kind identifier for the tool
    description : Optional[str]
        A short description of the tool for metadata purposes
    bindings : Optional[list[Binding]]
        Tool argument bindings to input properties
    """

    name: str = field(default="")
    kind: str = field(default="")
    description: Optional[str] = None
    bindings: Optional[list[Binding]] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "Tool":
        """Load a Tool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Tool: {data}")

        # load polymorphic Tool instance
        instance = Tool.load_kind(data)
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "bindings" in data:
            instance.bindings = Tool.load_bindings(data["bindings"])
        return instance

    @staticmethod
    def load_bindings(data: dict | list) -> list[Binding]:
        if isinstance(data, dict):
            # convert simple named bindings to list of Binding
            if len(data.keys()) == 1:
                data = [{"name": k, "input": v} for k, v in data.items()]
            else:
                data = [{"name": k, **v} for k, v in data.items()]
        return [Binding.load(item) for item in data]

    @staticmethod
    def load_kind(data: dict) -> "Tool":
        # load polymorphic Tool instance
        if data is not None and "kind" in data:
            discriminator_value = str(data["kind"]).lower()
            if discriminator_value == "function":
                return FunctionTool.load(data)
            elif discriminator_value == "bing_search":
                return WebSearchTool.load(data)
            elif discriminator_value == "file_search":
                return FileSearchTool.load(data)
            elif discriminator_value == "mcp":
                return McpTool.load(data)
            elif discriminator_value == "openapi":
                return OpenApiTool.load(data)
            elif discriminator_value == "code_interpreter":
                return CodeInterpreterTool.load(data)
            else:
                # load default instance
                return CustomTool.load(data)
        else:
            raise ValueError("Missing Tool discriminator property: 'kind'")


@dataclass
class FunctionTool(Tool):
    """Represents a local function tool.
    Attributes
    ----------
    kind : str
        The kind identifier for function tools
    parameters : PropertySchema
        Parameters accepted by the function tool
    strict : Optional[bool]
        Indicates whether the function tool enforces strict validation on its parameters
    """

    kind: str = field(default="function")
    parameters: PropertySchema = field(default_factory=PropertySchema)
    strict: Optional[bool] = None

    @staticmethod
    def load(data: Any) -> "FunctionTool":
        """Load a FunctionTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for FunctionTool: {data}")

        # create new instance
        instance = FunctionTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "parameters" in data:
            instance.parameters = PropertySchema.load(data["parameters"])
        if data is not None and "strict" in data:
            instance.strict = data["strict"]
        return instance


@dataclass
class CustomTool(Tool):
    """Represents a generic server tool that runs on a serverThis tool kind is designed for operations that require server-side executionIt may include features such as authentication, data storage, and long-running processesThis tool kind is ideal for tasks that involve complex computations or access to secure resourcesServer tools can be used to offload heavy processing from client applications
    Attributes
    ----------
    kind : str
        The kind identifier for server tools. This is a wildcard and can represent any server tool type not explicitly defined.
    connection : Connection
        Connection configuration for the server tool
    options : dict[str, Any]
        Configuration options for the server tool
    """

    kind: str = field(default="*")
    connection: Connection = field(default_factory=Connection)
    options: dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def load(data: Any) -> "CustomTool":
        """Load a CustomTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for CustomTool: {data}")

        # create new instance
        instance = CustomTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"])
        if data is not None and "options" in data:
            instance.options = data["options"]
        return instance


@dataclass
class WebSearchTool(Tool):
    """The Bing search tool.
    Attributes
    ----------
    kind : str
        The kind identifier for Bing search tools
    connection : Connection
        The connection configuration for the Bing search tool
    options : Optional[dict[str, Any]]
        The configuration options for the Bing search tool
    """

    kind: str = field(default="bing_search")
    connection: Connection = field(default_factory=Connection)
    options: Optional[dict[str, Any]] = None

    @staticmethod
    def load(data: Any) -> "WebSearchTool":
        """Load a WebSearchTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for WebSearchTool: {data}")

        # create new instance
        instance = WebSearchTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"])
        if data is not None and "options" in data:
            instance.options = data["options"]
        return instance


@dataclass
class FileSearchTool(Tool):
    """A tool for searching files.This tool allows an AI agent to search for files based on a query.
    Attributes
    ----------
    kind : str
        The kind identifier for file search tools
    connection : Connection
        The connection configuration for the file search tool
    vectorStoreIds : list[str]
        The IDs of the vector stores to search within.
    maximumResultCount : Optional[int]
        The maximum number of search results to return.
    ranker : Optional[str]
        File search ranker.
    scoreThreshold : Optional[float]
        Ranker search threshold.
    filters : Optional[dict[str, Any]]
        Additional filters to apply during the file search.
    """

    kind: str = field(default="file_search")
    connection: Connection = field(default_factory=Connection)
    vectorStoreIds: list[str] = field(default_factory=list)
    maximumResultCount: Optional[int] = None
    ranker: Optional[str] = None
    scoreThreshold: Optional[float] = None
    filters: Optional[dict[str, Any]] = None

    @staticmethod
    def load(data: Any) -> "FileSearchTool":
        """Load a FileSearchTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for FileSearchTool: {data}")

        # create new instance
        instance = FileSearchTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"])
        if data is not None and "vectorStoreIds" in data:
            instance.vectorStoreIds = data["vectorStoreIds"]
        if data is not None and "maximumResultCount" in data:
            instance.maximumResultCount = data["maximumResultCount"]
        if data is not None and "ranker" in data:
            instance.ranker = data["ranker"]
        if data is not None and "scoreThreshold" in data:
            instance.scoreThreshold = data["scoreThreshold"]
        if data is not None and "filters" in data:
            instance.filters = data["filters"]
        return instance


@dataclass
class McpTool(Tool):
    """The MCP Server tool.
    Attributes
    ----------
    kind : str
        The kind identifier for MCP tools
    connection : Connection
        The connection configuration for the MCP tool
    serverName : str
        The server name of the MCP tool
    serverDescription : Optional[str]
        The description of the MCP tool
    approvalMode : McpServerApprovalMode
        The approval mode for the MCP tool, either 'auto' or 'manual'
    allowedTools : Optional[list[str]]
        List of allowed operations or resources for the MCP tool
    """

    kind: str = field(default="mcp")
    connection: Connection = field(default_factory=Connection)
    serverName: str = field(default="")
    serverDescription: Optional[str] = None
    approvalMode: McpServerApprovalMode = field(default_factory=McpServerApprovalMode)
    allowedTools: Optional[list[str]] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "McpTool":
        """Load a McpTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for McpTool: {data}")

        # create new instance
        instance = McpTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"])
        if data is not None and "serverName" in data:
            instance.serverName = data["serverName"]
        if data is not None and "serverDescription" in data:
            instance.serverDescription = data["serverDescription"]
        if data is not None and "approvalMode" in data:
            instance.approvalMode = McpServerApprovalMode.load(data["approvalMode"])
        if data is not None and "allowedTools" in data:
            instance.allowedTools = data["allowedTools"]
        return instance


@dataclass
class OpenApiTool(Tool):
    """
    Attributes
    ----------
    kind : str
        The kind identifier for OpenAPI tools
    connection : Connection
        The connection configuration for the OpenAPI tool
    specification : str
        The full OpenAPI specification
    """

    kind: str = field(default="openapi")
    connection: Connection = field(default_factory=Connection)
    specification: str = field(default="")

    @staticmethod
    def load(data: Any) -> "OpenApiTool":
        """Load a OpenApiTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for OpenApiTool: {data}")

        # create new instance
        instance = OpenApiTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "connection" in data:
            instance.connection = Connection.load(data["connection"])
        if data is not None and "specification" in data:
            instance.specification = data["specification"]
        return instance


@dataclass
class CodeInterpreterTool(Tool):
    """A tool for interpreting and executing code.This tool allows an AI agent to run code snippets and analyze data files.
    Attributes
    ----------
    kind : str
        The kind identifier for code interpreter tools
    fileIds : list[str]
        The IDs of the files to be used by the code interpreter tool.
    """

    kind: str = field(default="code_interpreter")
    fileIds: list[str] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "CodeInterpreterTool":
        """Load a CodeInterpreterTool instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for CodeInterpreterTool: {data}")

        # create new instance
        instance = CodeInterpreterTool()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "fileIds" in data:
            instance.fileIds = data["fileIds"]
        return instance
